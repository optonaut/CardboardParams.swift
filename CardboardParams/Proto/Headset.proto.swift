// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source file Headset.proto

import Foundation
import ProtocolBuffers


public func == (lhs: Headset, rhs: Headset) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVendor == rhs.hasVendor) && (!lhs.hasVendor || lhs.vendor == rhs.vendor)
  fieldCheck = fieldCheck && (lhs.hasModel == rhs.hasModel) && (!lhs.hasModel || lhs.model == rhs.model)
  fieldCheck = fieldCheck && (lhs.hasScreenToLensDistance == rhs.hasScreenToLensDistance) && (!lhs.hasScreenToLensDistance || lhs.screenToLensDistance == rhs.screenToLensDistance)
  fieldCheck = fieldCheck && (lhs.hasInterLensDistance == rhs.hasInterLensDistance) && (!lhs.hasInterLensDistance || lhs.interLensDistance == rhs.interLensDistance)
  fieldCheck = fieldCheck && (lhs.leftEyeFieldOfViewAngles == rhs.leftEyeFieldOfViewAngles)
  fieldCheck = fieldCheck && (lhs.hasTrayToLensDistance == rhs.hasTrayToLensDistance) && (!lhs.hasTrayToLensDistance || lhs.trayToLensDistance == rhs.trayToLensDistance)
  fieldCheck = fieldCheck && (lhs.distortionCoefficients == rhs.distortionCoefficients)
  fieldCheck = fieldCheck && (lhs.hasHasMagnet == rhs.hasHasMagnet) && (!lhs.hasHasMagnet || lhs.hasMagnet == rhs.hasMagnet)
  fieldCheck = fieldCheck && (lhs.hasVerticalAlignment == rhs.hasVerticalAlignment) && (!lhs.hasVerticalAlignment || lhs.verticalAlignment == rhs.verticalAlignment)
  fieldCheck = fieldCheck && (lhs.hasPrimaryButton == rhs.hasPrimaryButton) && (!lhs.hasPrimaryButton || lhs.primaryButton == rhs.primaryButton)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public struct HeadsetRoot {
  public static var sharedInstance : HeadsetRoot {
   struct Static {
       static let instance : HeadsetRoot = HeadsetRoot()
   }
   return Static.instance
  }
  public var extensionRegistry:ExtensionRegistry

  init() {
    extensionRegistry = ExtensionRegistry()
    registerAllExtensions(extensionRegistry)
  }
  public func registerAllExtensions(registry:ExtensionRegistry) {
  }
}

final public class Headset : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var vendor:String = ""

  public private(set) var hasVendor:Bool = false
  public private(set) var model:String = ""

  public private(set) var hasModel:Bool = false
  public private(set) var screenToLensDistance:Float = Float(0)

  public private(set) var hasScreenToLensDistance:Bool = false
  public private(set) var interLensDistance:Float = Float(0)

  public private(set) var hasInterLensDistance:Bool = false
  public private(set) var leftEyeFieldOfViewAngles:Array<Float> = Array<Float>()
  private var leftEyeFieldOfViewAnglesMemoizedSerializedSize:Int32 = -1
  public private(set) var trayToLensDistance:Float = Float(0)

  public private(set) var hasTrayToLensDistance:Bool = false
  public private(set) var distortionCoefficients:Array<Float> = Array<Float>()
  private var distortionCoefficientsMemoizedSerializedSize:Int32 = -1
  public private(set) var hasMagnet:Bool = false

  public private(set) var hasHasMagnet:Bool = false
  public private(set) var verticalAlignment:Int32 = Int32(0)

  public private(set) var hasVerticalAlignment:Bool = false
  public private(set) var primaryButton:Int32 = Int32(0)

  public private(set) var hasPrimaryButton:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasVendor {
      try output.writeString(1, value:vendor)
    }
    if hasModel {
      try output.writeString(2, value:model)
    }
    if hasScreenToLensDistance {
      try output.writeFloat(3, value:screenToLensDistance)
    }
    if hasInterLensDistance {
      try output.writeFloat(4, value:interLensDistance)
    }
    if !leftEyeFieldOfViewAngles.isEmpty {
      try output.writeRawVarint32(42)
      try output.writeRawVarint32(leftEyeFieldOfViewAnglesMemoizedSerializedSize)
      for oneValueleftEyeFieldOfViewAngles in leftEyeFieldOfViewAngles {
        try output.writeFloatNoTag(oneValueleftEyeFieldOfViewAngles)
      }
    }
    if hasTrayToLensDistance {
      try output.writeFloat(6, value:trayToLensDistance)
    }
    if !distortionCoefficients.isEmpty {
      try output.writeRawVarint32(58)
      try output.writeRawVarint32(distortionCoefficientsMemoizedSerializedSize)
      for oneValuedistortionCoefficients in distortionCoefficients {
        try output.writeFloatNoTag(oneValuedistortionCoefficients)
      }
    }
    if hasHasMagnet {
      try output.writeBool(10, value:hasMagnet)
    }
    if hasVerticalAlignment {
      try output.writeInt32(11, value:verticalAlignment)
    }
    if hasPrimaryButton {
      try output.writeInt32(12, value:primaryButton)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasVendor {
      serialize_size += vendor.computeStringSize(1)
    }
    if hasModel {
      serialize_size += model.computeStringSize(2)
    }
    if hasScreenToLensDistance {
      serialize_size += screenToLensDistance.computeFloatSize(3)
    }
    if hasInterLensDistance {
      serialize_size += interLensDistance.computeFloatSize(4)
    }
    var dataSizeLeftEyeFieldOfViewAngles:Int32 = 0
    dataSizeLeftEyeFieldOfViewAngles = 4 * Int32(leftEyeFieldOfViewAngles.count)
    serialize_size += dataSizeLeftEyeFieldOfViewAngles
    if !leftEyeFieldOfViewAngles.isEmpty {
      serialize_size += 1
      serialize_size += dataSizeLeftEyeFieldOfViewAngles.computeInt32SizeNoTag()
    }
    leftEyeFieldOfViewAnglesMemoizedSerializedSize = dataSizeLeftEyeFieldOfViewAngles
    if hasTrayToLensDistance {
      serialize_size += trayToLensDistance.computeFloatSize(6)
    }
    var dataSizeDistortionCoefficients:Int32 = 0
    dataSizeDistortionCoefficients = 4 * Int32(distortionCoefficients.count)
    serialize_size += dataSizeDistortionCoefficients
    if !distortionCoefficients.isEmpty {
      serialize_size += 1
      serialize_size += dataSizeDistortionCoefficients.computeInt32SizeNoTag()
    }
    distortionCoefficientsMemoizedSerializedSize = dataSizeDistortionCoefficients
    if hasHasMagnet {
      serialize_size += hasMagnet.computeBoolSize(10)
    }
    if hasVerticalAlignment {
      serialize_size += verticalAlignment.computeInt32Size(11)
    }
    if hasPrimaryButton {
      serialize_size += primaryButton.computeInt32Size(12)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Headset> {
    var mergedArray = Array<Headset>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Headset? {
    return try Headset.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> Headset {
    return try Headset.Builder().mergeFromData(data, extensionRegistry:HeadsetRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Headset {
    return try Headset.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> Headset {
    return try Headset.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Headset {
    return try Headset.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Headset {
    return try Headset.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Headset {
    return try Headset.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Headset.Builder {
    return Headset.classBuilder() as! Headset.Builder
  }
  public func getBuilder() -> Headset.Builder {
    return classBuilder() as! Headset.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Headset.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Headset.Builder()
  }
  public func toBuilder() throws -> Headset.Builder {
    return try Headset.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:Headset) throws -> Headset.Builder {
    return try Headset.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasVendor {
      output += "\(indent) vendor: \(vendor) \n"
    }
    if hasModel {
      output += "\(indent) model: \(model) \n"
    }
    if hasScreenToLensDistance {
      output += "\(indent) screenToLensDistance: \(screenToLensDistance) \n"
    }
    if hasInterLensDistance {
      output += "\(indent) interLensDistance: \(interLensDistance) \n"
    }
    var leftEyeFieldOfViewAnglesElementIndex:Int = 0
    for oneValueleftEyeFieldOfViewAngles in leftEyeFieldOfViewAngles  {
        output += "\(indent) leftEyeFieldOfViewAngles[\(leftEyeFieldOfViewAnglesElementIndex)]: \(oneValueleftEyeFieldOfViewAngles)\n"
        leftEyeFieldOfViewAnglesElementIndex += 1
    }
    if hasTrayToLensDistance {
      output += "\(indent) trayToLensDistance: \(trayToLensDistance) \n"
    }
    var distortionCoefficientsElementIndex:Int = 0
    for oneValuedistortionCoefficients in distortionCoefficients  {
        output += "\(indent) distortionCoefficients[\(distortionCoefficientsElementIndex)]: \(oneValuedistortionCoefficients)\n"
        distortionCoefficientsElementIndex += 1
    }
    if hasHasMagnet {
      output += "\(indent) hasMagnet: \(hasMagnet) \n"
    }
    if hasVerticalAlignment {
      output += "\(indent) verticalAlignment: \(verticalAlignment) \n"
    }
    if hasPrimaryButton {
      output += "\(indent) primaryButton: \(primaryButton) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasVendor {
             hashCode = (hashCode &* 31) &+ vendor.hashValue
          }
          if hasModel {
             hashCode = (hashCode &* 31) &+ model.hashValue
          }
          if hasScreenToLensDistance {
             hashCode = (hashCode &* 31) &+ screenToLensDistance.hashValue
          }
          if hasInterLensDistance {
             hashCode = (hashCode &* 31) &+ interLensDistance.hashValue
          }
          for oneValueleftEyeFieldOfViewAngles in leftEyeFieldOfViewAngles {
              hashCode = (hashCode &* 31) &+ oneValueleftEyeFieldOfViewAngles.hashValue
          }
          if hasTrayToLensDistance {
             hashCode = (hashCode &* 31) &+ trayToLensDistance.hashValue
          }
          for oneValuedistortionCoefficients in distortionCoefficients {
              hashCode = (hashCode &* 31) &+ oneValuedistortionCoefficients.hashValue
          }
          if hasHasMagnet {
             hashCode = (hashCode &* 31) &+ hasMagnet.hashValue
          }
          if hasVerticalAlignment {
             hashCode = (hashCode &* 31) &+ verticalAlignment.hashValue
          }
          if hasPrimaryButton {
             hashCode = (hashCode &* 31) &+ primaryButton.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Headset"
  }
  override public func className() -> String {
      return "Headset"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Headset.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Headset = Headset()
    public func getMessage() -> Headset {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasVendor:Bool {
         get {
              return builderResult.hasVendor
         }
    }
    public var vendor:String {
         get {
              return builderResult.vendor
         }
         set (value) {
             builderResult.hasVendor = true
             builderResult.vendor = value
         }
    }
    public func setVendor(value:String) -> Headset.Builder {
      self.vendor = value
      return self
    }
    public func clearVendor() -> Headset.Builder{
         builderResult.hasVendor = false
         builderResult.vendor = ""
         return self
    }
    public var hasModel:Bool {
         get {
              return builderResult.hasModel
         }
    }
    public var model:String {
         get {
              return builderResult.model
         }
         set (value) {
             builderResult.hasModel = true
             builderResult.model = value
         }
    }
    public func setModel(value:String) -> Headset.Builder {
      self.model = value
      return self
    }
    public func clearModel() -> Headset.Builder{
         builderResult.hasModel = false
         builderResult.model = ""
         return self
    }
    public var hasScreenToLensDistance:Bool {
         get {
              return builderResult.hasScreenToLensDistance
         }
    }
    public var screenToLensDistance:Float {
         get {
              return builderResult.screenToLensDistance
         }
         set (value) {
             builderResult.hasScreenToLensDistance = true
             builderResult.screenToLensDistance = value
         }
    }
    public func setScreenToLensDistance(value:Float) -> Headset.Builder {
      self.screenToLensDistance = value
      return self
    }
    public func clearScreenToLensDistance() -> Headset.Builder{
         builderResult.hasScreenToLensDistance = false
         builderResult.screenToLensDistance = Float(0)
         return self
    }
    public var hasInterLensDistance:Bool {
         get {
              return builderResult.hasInterLensDistance
         }
    }
    public var interLensDistance:Float {
         get {
              return builderResult.interLensDistance
         }
         set (value) {
             builderResult.hasInterLensDistance = true
             builderResult.interLensDistance = value
         }
    }
    public func setInterLensDistance(value:Float) -> Headset.Builder {
      self.interLensDistance = value
      return self
    }
    public func clearInterLensDistance() -> Headset.Builder{
         builderResult.hasInterLensDistance = false
         builderResult.interLensDistance = Float(0)
         return self
    }
    public var leftEyeFieldOfViewAngles:Array<Float> {
         get {
             return builderResult.leftEyeFieldOfViewAngles
         }
         set (array) {
             builderResult.leftEyeFieldOfViewAngles = array
         }
    }
    public func setLeftEyeFieldOfViewAngles(value:Array<Float>) -> Headset.Builder {
      self.leftEyeFieldOfViewAngles = value
      return self
    }
    public func clearLeftEyeFieldOfViewAngles() -> Headset.Builder {
       builderResult.leftEyeFieldOfViewAngles.removeAll(keepCapacity: false)
       return self
    }
    public var hasTrayToLensDistance:Bool {
         get {
              return builderResult.hasTrayToLensDistance
         }
    }
    public var trayToLensDistance:Float {
         get {
              return builderResult.trayToLensDistance
         }
         set (value) {
             builderResult.hasTrayToLensDistance = true
             builderResult.trayToLensDistance = value
         }
    }
    public func setTrayToLensDistance(value:Float) -> Headset.Builder {
      self.trayToLensDistance = value
      return self
    }
    public func clearTrayToLensDistance() -> Headset.Builder{
         builderResult.hasTrayToLensDistance = false
         builderResult.trayToLensDistance = Float(0)
         return self
    }
    public var distortionCoefficients:Array<Float> {
         get {
             return builderResult.distortionCoefficients
         }
         set (array) {
             builderResult.distortionCoefficients = array
         }
    }
    public func setDistortionCoefficients(value:Array<Float>) -> Headset.Builder {
      self.distortionCoefficients = value
      return self
    }
    public func clearDistortionCoefficients() -> Headset.Builder {
       builderResult.distortionCoefficients.removeAll(keepCapacity: false)
       return self
    }
    public var hasHasMagnet:Bool {
         get {
              return builderResult.hasHasMagnet
         }
    }
    public var hasMagnet:Bool {
         get {
              return builderResult.hasMagnet
         }
         set (value) {
             builderResult.hasHasMagnet = true
             builderResult.hasMagnet = value
         }
    }
    public func setHasMagnet(value:Bool) -> Headset.Builder {
      self.hasMagnet = value
      return self
    }
    public func clearHasMagnet() -> Headset.Builder{
         builderResult.hasHasMagnet = false
         builderResult.hasMagnet = false
         return self
    }
    public var hasVerticalAlignment:Bool {
         get {
              return builderResult.hasVerticalAlignment
         }
    }
    public var verticalAlignment:Int32 {
         get {
              return builderResult.verticalAlignment
         }
         set (value) {
             builderResult.hasVerticalAlignment = true
             builderResult.verticalAlignment = value
         }
    }
    public func setVerticalAlignment(value:Int32) -> Headset.Builder {
      self.verticalAlignment = value
      return self
    }
    public func clearVerticalAlignment() -> Headset.Builder{
         builderResult.hasVerticalAlignment = false
         builderResult.verticalAlignment = Int32(0)
         return self
    }
    public var hasPrimaryButton:Bool {
         get {
              return builderResult.hasPrimaryButton
         }
    }
    public var primaryButton:Int32 {
         get {
              return builderResult.primaryButton
         }
         set (value) {
             builderResult.hasPrimaryButton = true
             builderResult.primaryButton = value
         }
    }
    public func setPrimaryButton(value:Int32) -> Headset.Builder {
      self.primaryButton = value
      return self
    }
    public func clearPrimaryButton() -> Headset.Builder{
         builderResult.hasPrimaryButton = false
         builderResult.primaryButton = Int32(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Headset.Builder {
      builderResult = Headset()
      return self
    }
    public override func clone() throws -> Headset.Builder {
      return try Headset.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Headset {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Headset {
      let returnMe:Headset = builderResult
      return returnMe
    }
    public func mergeFrom(other:Headset) throws -> Headset.Builder {
      if other == Headset() {
       return self
      }
      if other.hasVendor {
           vendor = other.vendor
      }
      if other.hasModel {
           model = other.model
      }
      if other.hasScreenToLensDistance {
           screenToLensDistance = other.screenToLensDistance
      }
      if other.hasInterLensDistance {
           interLensDistance = other.interLensDistance
      }
      if !other.leftEyeFieldOfViewAngles.isEmpty {
          builderResult.leftEyeFieldOfViewAngles += other.leftEyeFieldOfViewAngles
      }
      if other.hasTrayToLensDistance {
           trayToLensDistance = other.trayToLensDistance
      }
      if !other.distortionCoefficients.isEmpty {
          builderResult.distortionCoefficients += other.distortionCoefficients
      }
      if other.hasHasMagnet {
           hasMagnet = other.hasMagnet
      }
      if other.hasVerticalAlignment {
           verticalAlignment = other.verticalAlignment
      }
      if other.hasPrimaryButton {
           primaryButton = other.primaryButton
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Headset.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Headset.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          vendor = try input.readString()

        case 18 :
          model = try input.readString()

        case 29 :
          screenToLensDistance = try input.readFloat()

        case 37 :
          interLensDistance = try input.readFloat()

        case 42 :
          let length:Int32 = try input.readRawVarint32()
          let limit:Int32 = try input.pushLimit(length)
          while (input.bytesUntilLimit() > 0) {
            builderResult.leftEyeFieldOfViewAngles += [try input.readFloat()]
          }
          input.popLimit(limit)

        case 53 :
          trayToLensDistance = try input.readFloat()

        case 58 :
          let length:Int32 = try input.readRawVarint32()
          let limit:Int32 = try input.pushLimit(length)
          while (input.bytesUntilLimit() > 0) {
            builderResult.distortionCoefficients += [try input.readFloat()]
          }
          input.popLimit(limit)

        case 80 :
          hasMagnet = try input.readBool()

        case 88 :
          verticalAlignment = try input.readInt32()

        case 96 :
          primaryButton = try input.readInt32()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}


// @@protoc_insertion_point(global_scope)
